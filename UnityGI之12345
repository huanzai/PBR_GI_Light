
1. Enlighten vs Progressive。
  是否支持方向图由Lightmapping Setting->Directinal Mode觉得，一般不需要。

2. LIGHTMAP_ON vs DYNAMICLIGHTMAP_ON
struct UnityGIInput
{
    UnityLight light; // pixel light, sent from the engine

    float3 worldPos;
    half3 worldViewDir;
    half atten;
    half3 ambient;

    // interpolated lightmap UVs are passed as full float precision data to fragment shaders
    // so lightmapUV (which is used as a tmp inside of lightmap fragment shaders) should
    // also be full float precision to avoid data loss before sampling a texture.
    float4 lightmapUV; // .xy = static lightmap UV, .zw = dynamic lightmap UV
..
}

inline half4 VertexGIForward(VertexInput v, float3 posWorld, half3 normalWorld)
在VertexInput中uv0是原始uv，uv1用于静态lightmap，uv2用于动态lightmap，在这个函数中组织了ambientOrLightMapUV，rg是static lightmap使用，zw是dynamic lightmap使用，
会在FrameMentGI中赋值给UnityGIInput.lightmapUV。

inline UnityGI UnityGI_Base(UnityGIInput data, half occlusion, half3 normalWorld)
计算GI，使用lightmapUV，静态和动态lightmap分别加入了间接光的diffuse，如下：
UnityGI o_gi;
o_gi.indirect.diffuse= SubtractMainLightWithRealtimeAttenuationFromLightmap (
..)

3.静态物体occlusion使用shadowmask，动态或其他对象使用light probe volume。阴影是可以带有颜色的，纯粹的黑色阴影实际很少。阴影暗部进行补光（Baked light, 如守望先锋）

4.IBL主要体现在以下函数：
  inline half3 UnityGI_IndirectSpecular(UnityGIInput data, half occlusion, Unity_GlossyEnvironmentData glossIn)
  {
      ...
      half3 env0 = Unity_GlossyEnvironment (UNITY_PASS_TEXCUBE(unity_SpecCube0), data.probeHDR[0], glossIn);
  }
  
  ----------------------------------------------------------------------------------------
5. GfxDeviceObjects.h定义了一些的全局贴图，如IBL需要的全局高光
   enum BuiltinPerRendererTexture
   {
      kLightMapRealTime,
      kLightMapRealTimeDir,
      kLightMapBaked,
      kLightMapBakedDir,
      kProbeProxyVolume,
      kSpecularCube1,
      kSpecularCube2,

      kBuiltInTextureCountMax
   };
   ScriptableBatchRender.cpp包含了它们的生成使用过程，这个类的使用范围宏定义如下：
   #define     GFX_SUPPORTS_SRP_BATCHER        ((GFX_SUPPORTS_D3D11 || GFX_SUPPORTS_VULKAN || PLATFORM_PS4 || GFX_SUPPORTS_METAL) && (!GFX_SUPPORTS_XBOXONE))
   ----------------------------------------------------------------------以上应该没用到mobile------------------------------------
   BuiltinShaderProgramsName.h定义了所有的全局环境贴图，如下：(以及全局变换矩阵，vec4变量等)
   enum BuiltinShaderTexEnvParam
   {
      kShaderTexEnvWhite = 0,
      kShaderTexEnvBlack,
      kShaderTexEnvRed,
      kShaderTexEnvGray,
      kShaderTexEnvGrey, // TODO: synonims
      kShaderTexEnvGrayscaleRamp,
      kShaderTexEnvGreyscaleRamp, // TODO: synonims
      kShaderTexEnvBump,
      kShaderTexEnvBlackCube,
      kShaderTexEnvLightmap,
      kShaderTexEnvUnityLightmapLight,
      kShaderTexEnvUnityLightmapDir,
      kShaderTexEnvUnityShadowMask,
      kShaderTexEnvUnityDynamicLightmap,
      kShaderTexEnvUnityDynamicDirectionality,
      kShaderTexEnvUnityDynamicNormal,
      kShaderTexEnvDitherMaskLOD,
      kShaderTexEnvDitherMaskLOD2D,
      kShaderTexEnvRandomRotation,
      kShaderTexEnvNHxRoughness,
      kShaderTexEnvSpecCube,
      kShaderTexEnvSpecCube1,
      kShaderTexEnvProbeVolumeSH,
      kShaderTexEnvCount
   };
   如kShaderTexEnvSpecCube就是用于shader中的unity_SpecCube0，用于在UnityGI_IndirectSpecular中计算IBL间接高光。在C++中可以在ReflectionProbeCache.cpp中看到生成过程。
   它们在shader中的名字由下面的宏定义：
   #define BUILTIN_SHADER_PARAMS_TEXENVS   \
    "white",                            \
    "black",                            \
    "red",                              \
    "gray",                             \
    "grey",                             \
    "grayscaleRamp",                    \
    "greyscaleRamp",                    \
    "bump",                             \
    "blackCube",                        \
    "lightmap",                         \
    "unity_Lightmap",                   \
    "unity_LightmapInd",                \
    "unity_ShadowMask",         \
    "unity_DynamicLightmap",            \
    "unity_DynamicDirectionality",      \
    "unity_DynamicNormal",              \
    "_DitherMaskLOD",                   \
    "_DitherMaskLOD2D",                 \
    "unity_RandomRotation16",           \
    "unity_NHxRoughness",               \
    "unity_SpecCube0",                  \
    "unity_SpecCube1",                  \
    "unity_ProbeVolumeSH"               \
6. 动态lightmap，C++中的位置：RenderQueue.cpp
   static void SetupRealtimeLightmaps(const SharedLightmapSettingsData& lightmapper, UInt32 lightmapIndex, ShaderPassContext& passContext)
7. Progressive方式可关注BakeContextManager.h 以及 PVRJobRender.h
   底层调用：
   PVRJobCompositeLightmap::FailureCodes PVRJobCompositeLightmap::CompositeLightmapSIMD(...)
   static void CompositeIndirect(int width, int height, const float& indirectIntensity, const math::float4* indirect, const float* indirectSampleCounts, math::float4* output)
   生成光照图等。

   到了rl层，使用GIBakeFrameShader.rlsl做最终的渲染
   bool BakeContextManager::RenderLightmaps(const Hash128& hash, BakeLightmapTechnique* lightmapBake)
   bool LightmapBakeTechnique::Bake()---这里面填充了很多rl需要的参数
   void RenderTechnique::RenderFrame()----这是OpenRL的一套光线跟踪渲染插件的包装   

8. 环境光及lightmapuv来源：(对第2条的补充)
   inline half4 VertexGIForward(VertexInput v, float3 posWorld, half3 normalWorld)
   {
     ...unity_LightmapST
     ...unity_DynamicLightmapST
   }
   关注C++中kShaderVecUnityLightmapST以及kShaderVecUnityDynamicLightmapST，它们是构成环境光的主要部分。
   RenderNode的数据部分struct SharedRendererData，包含了
   Vector4f m_LightmapST[kLightmapTypeCount];       ///< Lightmap tiling and offset
   由此通过LightmapSTCache::ApplyLightmapST(..)传入shader中unity_LightmapST或unity_DynamicLightmapST
   算出ambientOrLightmapUV.xyzw(xy是静态lightmapuv，zw是动态lightmapuv。但是：如果开启了球协光照，即lightprob，
   那么ambientOrLightmapUV.rgb是直接作为环境光提供的)

   之后才是UnityGI_Base下对于这个uv的使用。

9. 主要的前向渲染过程如下：
   void DoForwardShaderRenderLoop(
    const RenderLoopContext& ctx,
    RenderObjectDataContainer& objects,
    const CullResults& cullResults,
    bool opaque,
    bool disableDynamicBatching,
    bool clearFrameBuffer,
    Camera::RenderFlag cameraRenderFlag)
    {
      ForwardShaderRenderLoop* renderLoop;
      ...
    }
    其中，处理shadow的步骤如下：
    renderLoop->PrepareShadowMaps(mainDirShadowLight, cullResults);
    const ShadowMapJobHeader* PrepareShadowMaps(const CullResults& cullResults, const ActiveLight& activeLight, const MinMaxAABB& receiverBounds)
    ...
    其次，核心的渲染流程如下：
    renderLoop->PerformRendering()--调用入口
    ~~~~~~~~~~~~~~~~
    StartRenderJobs(renderPassDataSortFence, opaque, mixShadowMaskAndRealtimeShadow, defaultPassContext);---调用如下：
    device.ExecuteAsync(...)---调用如下：
    static void ForwardRenderLoopJob(GfxDeviceAsyncCommand::ArgScratch* scratch, const GfxDeviceAsyncCommand::Arg* arg)---核心流程
    ~~~~~~~~
    可以看到预处理shadow是最外面的函数PrepareShadowMaps()来做的，主要是根据CullResult做了一次删减。通过五个队列来判断，一般只有前两个起作用，如下：
    enum
    {
        kStaticRenderers = 0,
        kDynamicRenderer,
        kSceneIntermediate,
        kCameraIntermediate,
    #if ENABLE_TERRAIN
        kTreeRenderer,
    #endif
        kVisibleListCount
    };

10. shadow采用PSSM，全屏shadow开启SHADOWS_SCREEN，点光源shadow开启SHADOWS_CUBE, directional光源开启SHADOWS_DEPTH.
    unity_ShadowFadeCenterAndType.xyz--shadow中心位置，w-是否采用球形裁剪(一般是true)

11. shadowmap使用：
    void ForwardShaderRenderLoop::RenderForwardShadowMaps(...)---一切的开始
    ||
    // shadow map of main directional light
    if (m_MainShadowMap.shadowCachingData || m_MainShadowMap.shadowJobHeader)--shadowJobHeader为true的时候为实时阴影(PSSM)
        RenderLightShadowMaps(m_MainShadowMap, enableSoftShadows, clearFrameBuffer, passContext);
    PCF只用于soft shadow模式，消耗比较大

12. BatchRender是底层使用的渲染器。
    RenderNode.h 中 ExecuteBatchedCallback executeBatchedCallback; 
    配置了多种BatchRender,如 RenderMultipleMeshes(..), BillboardRenderer_RenderMultiple(..),
    DrawInstancedMeshIntermediateRendererWithInstancing(..), DrawIndirectMeshIntermediateRendererBatched(..),
    DrawUtil::DrawLineOrTrailFromNodeQueue(..), s_MultipleRenderCallback[0][maskInteraction](..), DrawSpriteBatchedFromNodeQueue(..),
    总入口void BatchRenderer::EndLoopFlush()
    静态合批的条件：
    node.rendererData.m_StaticBatchInfo.subMeshCount > 0
    动态合批的条件：
    bool useDynamicBatching = meshBuffers.indexBuffer != NULL
                && renderData.extraArgs->enableDynamicBatching
                && batchIndexCount < kDynamicBatchingIndicesThreshold
                && topology != kPrimitiveLineStrip
                && secondaryMesh == NULL
                && !IsOddNegativeScaleTransform(node.rendererData.m_TransformInfo.transformType)
                && CanUseDynamicBatching(*mesh, dynamicBatchChannels, batchVertexCount, firstSubMesh.baseVertex)
    很苛刻，最终还是走void DrawUtil::DrawMeshRawFromNodeQueue(...)

    m_Context->m_Camera->SetupRender(passContext, cameraRenderFlag | Camera::kRenderFlagSetRenderTarget);
    完成最终的backbuffer拷贝，并复制到屏幕。

13. GfxDevice.h---通过相机访问以下两个常用rt
    RenderSurfaceHandle m_BackBufferColor;
    RenderSurfaceHandle m_BackBufferDepth;

14. Lightmap生成的最终渲染入口：AlbedoRender.cpp
    static void RenderAllTheObjects(GIRenderType renderType, const dynamic_array<AlbedoRendererObject>& objects, eRenderTextureType type)
    unity_MetaFragmentControl.x--Albedo
    unity_MetaFragmentControl.y--Emissive
    DrawUtil::DrawMeshRaw(vertexInput, *mesh1, subsets[i].second, instanceID, mesh2);--最后调用

15. shadow各项feature的组合体现在AutoLight.cginc(前向)
    half UnityComputeForwardShadows(float2 lightmapUV, float3 worldPos, float4 screenPos)
    {...}          详解如下：
    (1)烘焙阴影要么来自shadowmask，要么来自LPPV(动态对象)。ShadowMask模式在LightMap_On开启的时候从ShadowMask中取阴影，否则通过LPPV，而非ShadowMask模式只能通过LPPV取得阴影。
    //baked occlusion if any
    half shadowMaskAttenuation = UnitySampleBakedOcclusion(lightmapUV, worldPos);    
    (2)平行光的动态阴影(前提是没有用CSM的情况下，必须开启SHADOWS_SCREEN)
    //directional realtime shadow
    #if defined (SHADOWS_SCREEN)
        #if defined(UNITY_NO_SCREENSPACE_SHADOWS) && !defined(UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS)
            realtimeShadowAttenuation = unitySampleShadow(mul(unity_WorldToShadow[0], unityShadowCoord4(worldPos, 1)));
    (3)SpotLight阴影需要开启SHADOWS_DEPTH，点光源阴影需要开启SHADOWS_CUBE,
       它们都通过inline fixed UnitySampleShadowmap (float4 shadowCoord)计算实时阴影。
       这个时候可以看到软阴影的作用，PCF等

16. CSM在移动平台被限制为只有一个cascade，即等同于没有开启。
17. UnitySampleShadowmap(注意大写首字母！)是针对点光和spotlight的阴影计算，而unitySampleShadow则是针对开启SHADOWS_SCREEN的情况，即平行主光。
18. RealtimeLightmap补充：开启lighting中RealtimeLightmap,对需要实时gi的对象开启emissive及其GlobalRealtimeGI选项，并勾上static做烘焙。
19. C++中看到，如果开启了CSM，那么shader中UNITY_NO_SCREENSPACE_SHADOWS为false。即认为CSM是全屏阴影。如下：
    // Shadows
    const bool screenSpaceShadows = tierSettings.useCascadedShadowMaps && CanUseCascadedShadowMaps(compiler);
    keywords->set(kNoScreenSpaceShadows, !screenSpaceShadows);
    AutoLight.cginc一开始就声明了各项宏，正常情况下平行光走第一个分支(SHADOWS_SCREEN)+(UNITY_NO_SCREENSPACE_SHADOWS)
    移动平台默认是关掉CSM的，即使在QualitySetting中开启了也一样。(C++中调试)
20. half4 _LightShadowData,如下
    // R = 1-strength
    // G = 1.0 / shadowDistance
    // B = 1.0 / (shadowDistance - shadowStartFade)
    // A = -shadowStartFade / (shadowDistance - shadowStartFade)
    理论上点光源或spotlight最终的shadow来自shadowmap和shaowmask的最小的那个(shadowMask/subtructive),或lerp插值(RealtimeShadow/DistanceShadow)
    // Used by both the forward and the deferred rendering path
    half UnityMixRealtimeAndBakedShadows(half realtimeShadowAttenuation, half bakedShadowAttenuation, half fade)
    {...}
    默认开启LIGHTMAP_SHADOW_MIXING

21. fragForwardBaseInternal——>UNITY_LIGHT_ATTENUATION(atten, i, s.posWorld)
                           ——>#define UNITY_SHADOW_ATTENUATION(a, worldPos) SHADOW_ATTENUATION(a)
                           ——>#define SHADOW_ATTENUATION(a) unitySampleShadow(a._ShadowCoord)---最简单的平行光阴影
                           ——>fixed shadow = UNITY_SAMPLE_SHADOW(_ShadowMapTexture, shadowCoord.xyz);
                             shadow = _LightShadowData.r + shadow * (1-_LightShadowData.r);
                             return shadow;
    ...#define LIGHT_ATTENUATION(a) SHADOW_ATTENUATION(a)已经不用了，(4.x版本使用)

22.vec4 _ProjectionParams:(https://www.jianshu.com/p/df878a386bec)
   x = lightZFar / (lightZNear - lightZFar),
   y = (lightZNear * lightZFar) / (lightZNear - lightZFar), 
   z = light.GetShadowBias(), 
   w = light.GetShadowScaleBias()

23. normalWorld在GI中用到两处，一个是球协光照，一个是dir lightmap，参见Unity_GI(..)

24.最终的光照计算总结的好啊：(Diffuse + Specular) * shadow + (IndirectDiffuse + IndirectSpecular) * AO;