
1. Enlighten vs Progressive。
  是否支持方向图由Lightmapping Setting->Directinal Mode觉得，一般不需要。

2. LIGHTMAP_ON vs DYNAMICLIGHTMAP_ON
struct UnityGIInput
{
    UnityLight light; // pixel light, sent from the engine

    float3 worldPos;
    half3 worldViewDir;
    half atten;
    half3 ambient;

    // interpolated lightmap UVs are passed as full float precision data to fragment shaders
    // so lightmapUV (which is used as a tmp inside of lightmap fragment shaders) should
    // also be full float precision to avoid data loss before sampling a texture.
    float4 lightmapUV; // .xy = static lightmap UV, .zw = dynamic lightmap UV
..
}

inline half4 VertexGIForward(VertexInput v, float3 posWorld, half3 normalWorld)
在VertexInput中uv0是原始uv，uv1用于静态lightmap，uv2用于动态lightmap，在这个函数中组织了ambientOrLightMapUV，rg是static lightmap使用，zw是dynamic lightmap使用，
会在FrameMentGI中赋值给UnityGIInput.lightmapUV。

inline UnityGI UnityGI_Base(UnityGIInput data, half occlusion, half3 normalWorld)
计算GI，使用lightmapUV，静态和动态lightmap分别加入了间接光的diffuse，如下：
UnityGI o_gi;
o_gi.indirect.diffuse= SubtractMainLightWithRealtimeAttenuationFromLightmap (
..)

3.静态物体occlusion使用shadowmask，动态或其他对象使用light probe volume。阴影是带有颜色的，纯粹的黑色阴影实际很少。阴影暗部进行补光（Baked light, 如守望先锋）

4.IBL主要体现在以下函数：
  inline half3 UnityGI_IndirectSpecular(UnityGIInput data, half occlusion, Unity_GlossyEnvironmentData glossIn)
  {
      ...
      half3 env0 = Unity_GlossyEnvironment (UNITY_PASS_TEXCUBE(unity_SpecCube0), data.probeHDR[0], glossIn);
  }
  
  ----------------------------------------------------------------------------------------
5. GfxDeviceObjects.h定义了一些的全局贴图，如IBL需要的全局高光
   enum BuiltinPerRendererTexture
   {
      kLightMapRealTime,
      kLightMapRealTimeDir,
      kLightMapBaked,
      kLightMapBakedDir,
      kProbeProxyVolume,
      kSpecularCube1,
      kSpecularCube2,

      kBuiltInTextureCountMax
   };
   ScriptableBatchRender.cpp包含了它们的生成使用过程，这个类的使用范围宏定义如下：
   #define     GFX_SUPPORTS_SRP_BATCHER        ((GFX_SUPPORTS_D3D11 || GFX_SUPPORTS_VULKAN || PLATFORM_PS4 || GFX_SUPPORTS_METAL) && (!GFX_SUPPORTS_XBOXONE))
   ----------------------------------------------------------------------以上应该没用到mobile------------------------------------
   BuiltinShaderProgramsName.h定义了所有的全局环境贴图，如下：(以及全局变换矩阵，vec4变量等)
   enum BuiltinShaderTexEnvParam
   {
      kShaderTexEnvWhite = 0,
      kShaderTexEnvBlack,
      kShaderTexEnvRed,
      kShaderTexEnvGray,
      kShaderTexEnvGrey, // TODO: synonims
      kShaderTexEnvGrayscaleRamp,
      kShaderTexEnvGreyscaleRamp, // TODO: synonims
      kShaderTexEnvBump,
      kShaderTexEnvBlackCube,
      kShaderTexEnvLightmap,
      kShaderTexEnvUnityLightmapLight,
      kShaderTexEnvUnityLightmapDir,
      kShaderTexEnvUnityShadowMask,
      kShaderTexEnvUnityDynamicLightmap,
      kShaderTexEnvUnityDynamicDirectionality,
      kShaderTexEnvUnityDynamicNormal,
      kShaderTexEnvDitherMaskLOD,
      kShaderTexEnvDitherMaskLOD2D,
      kShaderTexEnvRandomRotation,
      kShaderTexEnvNHxRoughness,
      kShaderTexEnvSpecCube,
      kShaderTexEnvSpecCube1,
      kShaderTexEnvProbeVolumeSH,
      kShaderTexEnvCount
   };
   如kShaderTexEnvSpecCube就是用于shader中的unity_SpecCube0，用于在UnityGI_IndirectSpecular中计算IBL间接高光。在C++中可以在ReflectionProbeCache.cpp中看到生成过程。
   它们在shader中的名字由下面的宏定义：
   #define BUILTIN_SHADER_PARAMS_TEXENVS   \
    "white",                            \
    "black",                            \
    "red",                              \
    "gray",                             \
    "grey",                             \
    "grayscaleRamp",                    \
    "greyscaleRamp",                    \
    "bump",                             \
    "blackCube",                        \
    "lightmap",                         \
    "unity_Lightmap",                   \
    "unity_LightmapInd",                \
    "unity_ShadowMask",         \
    "unity_DynamicLightmap",            \
    "unity_DynamicDirectionality",      \
    "unity_DynamicNormal",              \
    "_DitherMaskLOD",                   \
    "_DitherMaskLOD2D",                 \
    "unity_RandomRotation16",           \
    "unity_NHxRoughness",               \
    "unity_SpecCube0",                  \
    "unity_SpecCube1",                  \
    "unity_ProbeVolumeSH"               \
6. 动态lightmap，C++中的位置：RenderQueue.cpp
   static void SetupRealtimeLightmaps(const SharedLightmapSettingsData& lightmapper, UInt32 lightmapIndex, ShaderPassContext& passContext)
7. Progressive方式可关注BakeContextManager.h 以及 PVRJobRender.h
   bool BakeContextManager::RenderLightmaps(const Hash128& hash, BakeLightmapTechnique* lightmapBake)
   bool LightmapBakeTechnique::Bake()---这里面填充了很多rl需要的参数
   void RenderTechnique::RenderFrame()----这是OpenRL的一套光线跟踪渲染插件的包装

8. 环境光及lightmapuv来源：(对第2条的补充)
   inline half4 VertexGIForward(VertexInput v, float3 posWorld, half3 normalWorld)
   {
     ...unity_LightmapST
     ...unity_DynamicLightmapST
   }
   关注C++中kShaderVecUnityLightmapST以及kShaderVecUnityDynamicLightmapST，它们是构成环境光的主要部分。
   RenderNode的数据部分struct SharedRendererData，包含了
   Vector4f m_LightmapST[kLightmapTypeCount];       ///< Lightmap tiling and offset
   由此通过LightmapSTCache::ApplyLightmapST(..)传入shader中unity_LightmapST或unity_DynamicLightmapST
   算出ambientOrLightmapUV.xyzw(xy是静态lightmapuv，zw是动态lightmapuv。但是：如果开启了球协光照，即lightprob，
   那么ambientOrLightmapUV.rgb是直接作为环境光提供的)

   之后才是UnityGI_Base下对于这个uv的使用。

9. 主要的前向渲染过程如下：
   void DoForwardShaderRenderLoop(
    const RenderLoopContext& ctx,
    RenderObjectDataContainer& objects,
    const CullResults& cullResults,
    bool opaque,
    bool disableDynamicBatching,
    bool clearFrameBuffer,
    Camera::RenderFlag cameraRenderFlag)
    {
      ForwardShaderRenderLoop* renderLoop;
      ...
    }
    其中，处理shadow的步骤如下：
    renderLoop->PrepareShadowMaps(mainDirShadowLight, cullResults);
    const ShadowMapJobHeader* PrepareShadowMaps(const CullResults& cullResults, const ActiveLight& activeLight, const MinMaxAABB& receiverBounds)
    ...
    其次，核心的渲染流程如下：
    renderLoop->PerformRendering()--调用入口
    ~~~~~~~~~~~~~~~~
    StartRenderJobs(renderPassDataSortFence, opaque, mixShadowMaskAndRealtimeShadow, defaultPassContext);---调用如下：
    device.ExecuteAsync(...)---调用如下：
    static void ForwardRenderLoopJob(GfxDeviceAsyncCommand::ArgScratch* scratch, const GfxDeviceAsyncCommand::Arg* arg)---核心流程
    ~~~~~~~~
    可以看到预处理shadow是最外面的函数PrepareShadowMaps()来做的，主要是根据CullResult做了一次删减。通过五个队列来判断，一般只有前两个起作用，如下：
    enum
    {
        kStaticRenderers = 0,
        kDynamicRenderer,
        kSceneIntermediate,
        kCameraIntermediate,
    #if ENABLE_TERRAIN
        kTreeRenderer,
    #endif
        kVisibleListCount
    };

10. shadow采用PSSM，SpotLight全屏shadow开启SHADOWS_SCREEN，点光源shadow开启SHADOWS_CUBE, directional光源开启SHADOWS_DEPTH.
    unity_ShadowFadeCenterAndType.xyz--shadow中心位置，w-是否采用球形裁剪(一般是true)

11. shadowd使用：
    void ForwardShaderRenderLoop::RenderForwardShadowMaps(...)---一切的开始
    ||
    // shadow map of main directional light
    if (m_MainShadowMap.shadowCachingData || m_MainShadowMap.shadowJobHeader)--shadowJobHeader为true的时候为实时阴影(PSSM)
        RenderLightShadowMaps(m_MainShadowMap, enableSoftShadows, clearFrameBuffer, passContext);
    PCF只用于soft shadow模式，消耗比较大

12. BatchRender是底层使用的渲染器。
    RenderNode.h 中 ExecuteBatchedCallback executeBatchedCallback; 
    配置了多种BatchRender,如 RenderMultipleMeshes(..), BillboardRenderer_RenderMultiple(..),
    DrawInstancedMeshIntermediateRendererWithInstancing(..), DrawIndirectMeshIntermediateRendererBatched(..),
    DrawUtil::DrawLineOrTrailFromNodeQueue(..), s_MultipleRenderCallback[0][maskInteraction](..), DrawSpriteBatchedFromNodeQueue(..),
    总入口void BatchRenderer::EndLoopFlush()
    静态合批的条件：
    node.rendererData.m_StaticBatchInfo.subMeshCount > 0
    动态合批的条件：
    bool useDynamicBatching = meshBuffers.indexBuffer != NULL
                && renderData.extraArgs->enableDynamicBatching
                && batchIndexCount < kDynamicBatchingIndicesThreshold
                && topology != kPrimitiveLineStrip
                && secondaryMesh == NULL
                && !IsOddNegativeScaleTransform(node.rendererData.m_TransformInfo.transformType)
                && CanUseDynamicBatching(*mesh, dynamicBatchChannels, batchVertexCount, firstSubMesh.baseVertex)
    很苛刻，最终还是走void DrawUtil::DrawMeshRawFromNodeQueue(...)

    m_Context->m_Camera->SetupRender(passContext, cameraRenderFlag | Camera::kRenderFlagSetRenderTarget);
    完成最终的backbuffer拷贝，并复制到屏幕。

13. GfxDevice.h---通过相机访问以下两个常用rt
    RenderSurfaceHandle m_BackBufferColor;
    RenderSurfaceHandle m_BackBufferDepth;